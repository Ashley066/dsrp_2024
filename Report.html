<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.555">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Ashley Raj">

<title>The Influence of Main and Minor Character Lines from The Office on an Episode’s Average Sentiment Score</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="Report_files/libs/clipboard/clipboard.min.js"></script>
<script src="Report_files/libs/quarto-html/quarto.js"></script>
<script src="Report_files/libs/quarto-html/popper.min.js"></script>
<script src="Report_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Report_files/libs/quarto-html/anchor.min.js"></script>
<link href="Report_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Report_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Report_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Report_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Report_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">The Influence of Main and Minor Character Lines from The Office on an Episode’s Average Sentiment Score</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Ashley Raj </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="abstract" class="level2">
<h2 class="anchored" data-anchor-id="abstract">Abstract</h2>
<section id="problem" class="level3">
<h3 class="anchored" data-anchor-id="problem">Problem</h3>
<p>This study investigates whether we can predict the average sentiment score of episodes from the popular sitcom called “The Office” based on the number of main and minor character lines spoken in the episode.</p>
</section>
<section id="approach" class="level3">
<h3 class="anchored" data-anchor-id="approach">Approach</h3>
<p>After performing data preparation and cleaning, a box plot of the sentiment score by the top 10 characters in the show, including both minor and major character, was created. The box plot represented the difference in sentiment scores between the minor and major characters over the seasons, where the major characters had the most variability in their lines due to the outliers and their high IQR ranges. A graph of their average sentiment scores of each season was created, where the average sentiment scores were higher for seasons with a larger number of main characters present. An anova test was conducted to determine the effect of the number of main and minor character lines on the average sentiment score. A linear regression model was used to test out the hypothesis, and several versions were made. After conducting anova tests on these models, the variables that were relevant were: “main_character_lines”, “minor_character_lines”, “season_factor”, and “interaction_factor”. The accuracy was determined by calculating the R^2 value and the Mean Squared Error.</p>
</section>
<section id="results" class="level3">
<h3 class="anchored" data-anchor-id="results">Results</h3>
<p>After running several anova tests, the most successful linear regression model was “lr_model_w_out_imdb_ratings_squares” with an R^2 value of 0.2342289 and a Mean Squared Error of 0.001250424. Before determining which variables to keep, running an anova test on the linear regression model called “lr_model_interaction” revealed that the IMDB ratings and the minor and main character lines squared did not help the model due to their p-value being greater than 0.05. Removing those variables, resulted in the “lr_model_w_out_imdb_ratings_squares” able to explain 23.42% of the variance present in the data.</p>
</section>
<section id="conclusion" class="level3">
<h3 class="anchored" data-anchor-id="conclusion">Conclusion</h3>
<p>IMDB ratings per episode, the squared number of main character lines, and the squared number of minor character lines are not good indicators for predicting the average sentiment score for each episode. The number of minor and main character lines, the interaction variable (multiplying the major and minor character lines per episode), and the season the episode was from were suitable variables to predict the average sentiment score for each episode. Based on the data from the final linear regression model, the null hypothesis can be rejected, showing that the number of main and minor character lines do impact the average sentiment score of an episode from The Office.</p>
</section>
</section>
<section id="background" class="level2">
<h2 class="anchored" data-anchor-id="background">Background</h2>
<p>The Office is a popular sitcom due to its wide variety of characters and its different situations. The dataset used included the following variables: “season”, “episode”, “episode_name”, “director”, “writer”, “character”, “text”, “text_w_direction”, “imdb_rating”, “total_votes”, “air_date”, “sentiment_analysis_score”, “sentimentr_score”, and “syuzhet_score”. The sentiment scores measure the emotional tone and feeling expressed in a line of dialogue. Through data analysis, a trend observed was that seasons with a low number of main characters had a lower average sentiment score and seasons with all main characters present would have higher average sentiment scores. Additionally, through a box plot, major characters had the most variability of sentiment scores in their lines due to the outliers and their high IQR ranges.</p>
<p>This study investigates the effect that main and minor characters have on the emotional tone and attitude expressed in the episodes. The research question that was being investigated is “Can we predict the overall sentiment score of episodes based on how many main versus minor characters are in it?”. The null hypothesis was that the number of minor and main character lines would not have an effect on the average sentiment score while the alternative hypothesis would be that the number of minor and main characters would have a significant effect on the average sentiment score per episode.</p>
</section>
<section id="results-1" class="level2">
<h2 class="anchored" data-anchor-id="results-1">Results</h2>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="Report_files/figure-html/unnamed-chunk-1-1.gif" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Figure 1: Sentiment Score by Character</p>
<p>This plot shows the average sentiment score per main vs minor character. The characters in dark blue are main characters and the characters in light blue are the minor characters. The character lapse by their appearances per season, which is why certain characters like Erin and Andy appear later on the graph and why Micheal does not appear later on. This box-plot shows that main characters tend to have more extreme outliers and larger IQR ranges like Micheal and Jim.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="Report_files/figure-html/unnamed-chunk-2-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Figure 2: Final Average Sentiment Score Per Season</p>
<p>This plot shows the average sentiment score (using sentiment_analysis_score, sentimentr_score, and syuzhet_score values) per season, along with the average IMDB ratings. A darker purple color represents a high IMDB rating around 8.6 while a lighter blue color represents a lower IMDB rating around 7.8. Season 4 has a large number of main characters, which is why it has a higher average sentiment score and IMDB rating. Seasons 8 and 9 have a lower amount of main characters, which is why they have lower average sentiment scores and IMDB ratings.</p>
<div class="cell">
<div class="cell-output cell-output-stderr">
<pre><code>`geom_smooth()` using formula = 'y ~ x'</code></pre>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="Report_files/figure-html/unnamed-chunk-3-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>`geom_smooth()` using formula = 'y ~ x'</code></pre>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="Report_files/figure-html/unnamed-chunk-3-2.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Figures 3 and 4: Main Character Lines vs.&nbsp;Average Sentiment Scores and Minor Character Lines vs.&nbsp;Average Sentiment Scores. These graphs show the distribution of main vs minor character lines and the corresponding sentiment scores they received. The line of best fit can be seen as a straight horizontal line, showing the initial correlation to be weak.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="Report_files/figure-html/unnamed-chunk-4-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Figure 5: Predictions vs.&nbsp;Actual Sentiment Scores for the Initial Model. The factors I used to predict the average sentiment scores in this model was the number of main and minor character lines. The r-squared value was around 0.0218, showing that only 2.18% of the variance can be explained by the model. The initial model shows there is a low correlation, as the data points do not show an upward trend.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="Report_files/figure-html/unnamed-chunk-5-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Figure 6: Predictions vs Actual Sentiment Score for the Second Model. The factors used in this model were the number of main character lines, the number of minor character lines, and the IMDB ratings per episode. Based on the results from the anova test, the results from this model had improved but not significantly.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="Report_files/figure-html/unnamed-chunk-6-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Figure 7: Predictions vs Actual Sentiment Score for the Third Model. The factors from this model include the number of main character lines, the number of minor character lines, the number of main character lines squared, the number of minor character lines squared, the IMDB ratings of each episode, an interaction factor (the number of minor and main character lines multiplied with each other), and the season the episode was in. Based on the anova test conducted on this model, it performed significantly well from the previous two models. However, when performing a summary on this model, the factors that were negatively affecting the model were the number of minor and major character lines squared and the IMDB rating.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="Report_files/figure-html/unnamed-chunk-7-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Figure 8: Predictions vs Actual Sentiment Score for the Final Model. The final model contained the remaining factors that did not negatively effect the third model which was the number of main character lines, the number of minor character lines, the interaction factor, and the season the episode was in. This model significantly improved from the initial model, as its R-value had shown that 23.42% of the model’s variance can be explained by the model.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="Report_files/figure-html/unnamed-chunk-8-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Figure 9: RSS Value Comparisons between the Initial Model vs the Final Model. This plot shows that there were significant improvements from the initial and final model. The RSS value of the final model was significantly smaller than the initial model showing that there was a decrease in the likelihood of errors in the final model.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="Report_files/figure-html/unnamed-chunk-9-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Figure 10: R-squared Value Comparisons between the Initial Model vs the Final Model. This plot shows a significant improvement between the initial and final model. There was a significant increase in the R-squared value between the initial and final model. The R-squared value shows that 23.42% of the variance can be explained by the final model.</p>
</section>
<section id="discussion" class="level2">
<h2 class="anchored" data-anchor-id="discussion">Discussion</h2>
<p>Based on my results, I can reject the null hypothesis, thereby accepting the alternative hypothesis which is that the number of main and minor character lines do have an effect on the average sentiment score of an episode from The Office. While my R-squared value is not as preferably high, this is due to the fact that the dataset contains real-world data containing details about The Office. Through the creation of data plots and linear regression models, it can be concluded that the number of main and minor character lines have a significant effect on average sentiment score per episode.</p>
<p>This conclusion can show that understanding the roles different characters play and their dynamics can change content creation and viewer engagement. The Office was able to successfully use this idea to increase the numbers of viewers they had overtime by building upon main characters throughout the episodes. In the future, it can be investigated whether the increase in main character lines also leads to an increase in IMDB ratings, through similar data analysis and linear regression models. Ultimately, sentiment analysis can be applied to other fields including marketing, customer service, and healthcare, not only the entertainment industry to improve the standard of different products and forms of media.</p>
</section>
<section id="code-and-data-availability" class="level2">
<h2 class="anchored" data-anchor-id="code-and-data-availability">Code and Data Availability</h2>
<p>Here is a link to my GitHub repository:</p>
<p><a href="https://github.com/the-codingschool/DSRP-2024-Derek/tree/main/AshleyProject" class="uri">https://github.com/the-codingschool/DSRP-2024-Derek/tree/main/AshleyProject</a></p>
<p>The data used was called ‘office_sentiment.csv’, which comes from a tabular format.</p>
</section>
<section id="acknowledgements" class="level2">
<h2 class="anchored" data-anchor-id="acknowledgements">Acknowledgements</h2>
<p>I would like to thank The Coding School for giving me this wonderful opportunity to learn more about data science and delve deeper into this field. I would also like to thank the instructor Sarah Parker for teaching and explaining various concepts throughout the course. I would also like to thank my mentor Derek for introducing me to the dataset and offering me suggestions on how I can improve my outputs and results. I would also like to thank my teaching assistant Renate for answering any questions I had and offering my useful suggestions.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>